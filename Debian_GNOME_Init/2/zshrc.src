# „Äê$CURRENT_USER„Äë
# ~/.zshrc file for zsh non-login shells.
# see /usr/share/doc/zsh/examples/zshrc for examples

setopt autocd              # change directory just by typing its name
#setopt correct            # auto correct mistakes
setopt interactivecomments # allow comments in interactive mode
setopt ksharrays           # arrays start at 0
setopt magicequalsubst     # enable filename expansion for arguments of the form ‚Äòanything=expression‚Äô
setopt nonomatch           # hide error message if there is no match for the pattern
setopt notify              # report the status of background jobs immediately
setopt numericglobsort     # sort filenames numerically when it makes sense
setopt promptsubst         # enable command substitution in prompt

WORDCHARS=${WORDCHARS//\/} # Don't consider certain characters part of the word

# hide EOL sign ('%')
export PROMPT_EOL_MARK=""

# configure key keybindings
bindkey -e                                        # emacs key bindings
bindkey ' ' magic-space                           # do history expansion on space
bindkey '^[[3;5~' kill-word                       # ctrl + Supr
bindkey '^[[1;5C' forward-word                    # ctrl + ->
bindkey '^[[C' forward-word                       # ctrl + ->
bindkey '^[[1;5D' backward-word                   # ctrl + <-
bindkey '^[[D' backward-word                      # ctrl + <-
bindkey '^[[5~' beginning-of-buffer-or-history    # page up
bindkey '^[[6~' end-of-buffer-or-history          # page down
bindkey '^[[Z' undo                               # shift + tab undo last action

# enable completion features
autoload -Uz compinit
compinit -d ~/.cache/zcompdump
zstyle ':completion:*:*:*:*:*' menu select
zstyle ':completion:*' matcher-list 'm:{a-zA-Z}={A-Za-z}' # case insensitive tab completion

# History configurations
HISTFILE=~/.zsh_history
HISTSIZE=1000
SAVEHIST=2000
setopt hist_expire_dups_first # delete duplicates first when HISTFILE size exceeds HISTSIZE
setopt hist_ignore_dups       # ignore duplicated commands history list
setopt hist_ignore_space      # ignore commands that start with space
setopt hist_verify            # show command with history expansion to user before running it
#setopt share_history         # share command history data

# force zsh to show the complete history
alias history="history 0"

# make less more friendly for non-text input files, see lesspipe(1)
#[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color|*-256color) color_prompt=yes;;
esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
	# We have color support; assume it's compliant with Ecma-48
	# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
	# a case would tend to support setf rather than setaf.)
	color_prompt=yes
    else
	color_prompt=
    fi
fi

if [ "$color_prompt" = yes ]; then
    PROMPT=$'%F{%(#.blue.green)}‚îå‚îÄ‚îÄ${debian_chroot:+($debian_chroot)‚îÄ‚îÄ}(%B%F{%(#.red.blue)}%n%(#.üíÄ.„âø)%m%b%F{%(#.blue.green)})-[%B%F{reset}%(6~.%-1~/‚Ä¶/%4~.%5~)%b%F{%(#.blue.green)}]\n‚îî‚îÄ%B%(#.%F{red}#.%F{blue}$)%b%F{reset} '
    RPROMPT=$'%(?.. %? %F{red}%B‚®Ø%b%F{reset})%(1j. %j %F{yellow}%B‚öô%b%F{reset}.)'

    # enable syntax-highlighting
    if [ -f /usr/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh ] && [ "$color_prompt" = yes ]; then
	# ksharrays breaks the plugin. This is fixed now but let's disable it in the
	# meantime.
	# https://github.com/zsh-users/zsh-syntax-highlighting/pull/689
	unsetopt ksharrays
	. /usr/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
	ZSH_HIGHLIGHT_HIGHLIGHTERS=(main brackets pattern)
	ZSH_HIGHLIGHT_STYLES[default]=none
	ZSH_HIGHLIGHT_STYLES[unknown-token]=fg=red,bold
	ZSH_HIGHLIGHT_STYLES[reserved-word]=fg=cyan,bold
	ZSH_HIGHLIGHT_STYLES[suffix-alias]=fg=green,underline
	ZSH_HIGHLIGHT_STYLES[global-alias]=fg=magenta
	ZSH_HIGHLIGHT_STYLES[precommand]=fg=green,underline
	ZSH_HIGHLIGHT_STYLES[commandseparator]=fg=blue,bold
	ZSH_HIGHLIGHT_STYLES[autodirectory]=fg=green,underline
	ZSH_HIGHLIGHT_STYLES[path]=underline
	ZSH_HIGHLIGHT_STYLES[path_pathseparator]=
	ZSH_HIGHLIGHT_STYLES[path_prefix_pathseparator]=
	ZSH_HIGHLIGHT_STYLES[globbing]=fg=blue,bold
	ZSH_HIGHLIGHT_STYLES[history-expansion]=fg=blue,bold
	ZSH_HIGHLIGHT_STYLES[command-substitution]=none
	ZSH_HIGHLIGHT_STYLES[command-substitution-delimiter]=fg=magenta
	ZSH_HIGHLIGHT_STYLES[process-substitution]=none
	ZSH_HIGHLIGHT_STYLES[process-substitution-delimiter]=fg=magenta
	ZSH_HIGHLIGHT_STYLES[single-hyphen-option]=fg=magenta
	ZSH_HIGHLIGHT_STYLES[double-hyphen-option]=fg=magenta
	ZSH_HIGHLIGHT_STYLES[back-quoted-argument]=none
	ZSH_HIGHLIGHT_STYLES[back-quoted-argument-delimiter]=fg=blue,bold
	ZSH_HIGHLIGHT_STYLES[single-quoted-argument]=fg=yellow
	ZSH_HIGHLIGHT_STYLES[double-quoted-argument]=fg=yellow
	ZSH_HIGHLIGHT_STYLES[dollar-quoted-argument]=fg=yellow
	ZSH_HIGHLIGHT_STYLES[rc-quote]=fg=magenta
	ZSH_HIGHLIGHT_STYLES[dollar-double-quoted-argument]=fg=magenta
	ZSH_HIGHLIGHT_STYLES[back-double-quoted-argument]=fg=magenta
	ZSH_HIGHLIGHT_STYLES[back-dollar-quoted-argument]=fg=magenta
	ZSH_HIGHLIGHT_STYLES[assign]=none
	ZSH_HIGHLIGHT_STYLES[redirection]=fg=blue,bold
	ZSH_HIGHLIGHT_STYLES[comment]=fg=black,bold
	ZSH_HIGHLIGHT_STYLES[named-fd]=none
	ZSH_HIGHLIGHT_STYLES[numeric-fd]=none
	ZSH_HIGHLIGHT_STYLES[arg0]=fg=green
	ZSH_HIGHLIGHT_STYLES[bracket-error]=fg=red,bold
	ZSH_HIGHLIGHT_STYLES[bracket-level-1]=fg=blue,bold
	ZSH_HIGHLIGHT_STYLES[bracket-level-2]=fg=green,bold
	ZSH_HIGHLIGHT_STYLES[bracket-level-3]=fg=magenta,bold
	ZSH_HIGHLIGHT_STYLES[bracket-level-4]=fg=yellow,bold
	ZSH_HIGHLIGHT_STYLES[bracket-level-5]=fg=cyan,bold
	ZSH_HIGHLIGHT_STYLES[cursor-matchingbracket]=standout
    fi
else
    PROMPT='${debian_chroot:+($debian_chroot)}%n@%m:%~%# '
fi
unset color_prompt force_color_prompt

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
    TERM_TITLE='\e]0;${debian_chroot:+($debian_chroot)}%n@%m: %~\a'
    ;;
*)
    ;;
esac

new_line_before_prompt=yes
precmd() {
    # Print the previously configured title
    print -Pn "$TERM_TITLE"

    # Print a new line before the prompt, but only if it is not the first line
    if [ "$new_line_before_prompt" = yes ]; then
	if [ -z "$_NEW_LINE_BEFORE_PROMPT" ]; then
	    _NEW_LINE_BEFORE_PROMPT=1
	else
	    print ""
	fi
    fi
}

# enable color support of ls, less and man, and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
    alias diff='diff --color=auto'
    alias ip='ip --color=auto'

    export LESS_TERMCAP_mb=$'\E[1;31m'     # begin blink
    export LESS_TERMCAP_md=$'\E[1;36m'     # begin bold
    export LESS_TERMCAP_me=$'\E[0m'        # reset bold/blink
    export LESS_TERMCAP_so=$'\E[01;33m'    # begin reverse video
    export LESS_TERMCAP_se=$'\E[0m'        # reset reverse video
    export LESS_TERMCAP_us=$'\E[1;32m'     # begin underline
    export LESS_TERMCAP_ue=$'\E[0m'        # reset underline

    # Take advantage of $LS_COLORS for completion as well
    zstyle ':completion:*' list-colors "${(s.:.)LS_COLORS}"
fi

# some more ls aliases
# ÈªòËÆ§
alias ll='ls -l'
alias la='ls -A'
alias l='ls -CF'

# Git #
# Âü∫Á°Ä
# alias gst='git status'
# alias gss='git status --short'
alias gsb='git status --short --branch'

# add / commit
# alias ga='git add'
# alias gaa='git add --all'
# alias gapa='git add --patch'
# alias gc='git commit'
# alias gcm='git commit -m'
# alias gca='git commit --amend'
# ÊãâÂèñ‰ª£Á†Å
# ÈÖçÁΩÆGPG:  git config --global user.signingkey XXX Âíå git config --global commit.gpgsign true Á°Æ‰øù‰Ω†ÁöÑ Git Êèê‰∫§ÈÇÆÁÆ±ÂíåËøô‰∏™ key ÁöÑ uid ÈÇÆÁÆ±‰∏ÄËá¥ÔºàÂæàÈáçË¶ÅÔºâ
alias gplb='git pull --rebase --autostash && git branch -vv'
alias gcur='git branch --show-current'
# add all + commit with auto message (no sign)
gitac() {
  git add -A || return
  git commit -m "update ‚Äî‚Äî ($(date '+%Y-%m-%d %H:%M:%S'))"
}
# add all + commit with auto message (GPG sign)
gitacs() {
  git add -A || return
  git commit -S -m "update ‚Äî‚Äî ($(date '+%Y-%m-%d %H:%M:%S'))"
}
# add all + commit with custom message (no sign)
gitam() {
  if [[ $# -eq 0 ]]; then
    echo "Usage: gitam \"commit message\""
    return 1
  fi
  git add -A || return
  git commit -m "$*"
}
# add all + commit with custom message (GPG sign)
gitams() {
  if [[ $# -eq 0 ]]; then
    echo "Usage: gitams \"commit message\""
    return 1
  fi
  git add -A || return
  git commit -S -m "$*"
}

# Âø´ÈÄüÊü•ÁúãÊüê‰∏™Êñá‰ª∂ÔºàÊàñÁõÆÂΩïÔºâÂú®Êï¥‰∏™‰ªìÂ∫ìÂéÜÂè≤‰∏≠Âá∫Áé∞Âú®Âì™‰∫õÊèê‰∫§Èáå
gitFindFileHistory() {
  if [[ $# -eq 0 ]]; then
    echo "Usage: gitfindhistory <file-or-dir>"
    return 1
  fi
  git log --all --oneline -- "$@"
}
# gitÂàáÊç¢ÂàÜÊîØ(main dev)
git-switch() {
    local current=$(git rev-parse --abbrev-ref HEAD 2>/dev/null) || return 1
    local main_branch=""

    # Ê£ÄÊµã‰∏ªÂàÜÊîØÂêçÔºà‰ºòÂÖà mainÔºâ
    if git show-ref --verify --quiet refs/heads/main; then
        main_branch="main"
    elif git show-ref --verify --quiet refs/heads/master; then
        main_branch="master"
    fi

    if [ "$current" = "dev" ] && [ -n "$main_branch" ]; then
        echo "ÂàáÊç¢ dev ‚Üí $main_branch"
        git checkout "$main_branch"
    elif [ "$current" = "$main_branch" ]; then
        echo "ÂàáÊç¢ $main_branch ‚Üí dev"
        git checkout dev
    else
        echo "ÂΩìÂâçÂàÜÊîØ: $current (Êú™ÂÆö‰πâÂàáÊç¢ËßÑÂàô)"
    fi
}
alias gswitch=git-switch

# diff / log
# Êü•ÁúãÂ∑≤Áªè addÔºàÊöÇÂ≠òÂå∫ÔºâÁöÑÊîπÂä®
alias gds='git diff --staged'
# Áî®‰∏ÄË°å‰∏ÄÊù°ÁöÑÊñπÂºèÊü•ÁúãÊèê‰∫§ÂéÜÂè≤ÔºàÂê´ÂàÜÊîØ/Ê†áÁ≠æÔºâ
alias gl='git log --oneline --decorate'
# ‰ª•ÂõæÂΩ¢ÊñπÂºèÊü•ÁúãÊèê‰∫§ÂéÜÂè≤ÂíåÂàÜÊîØËµ∞Âêë
alias glog='git log --oneline --decorate --graph'

# branch / checkout / switch
# Êü•Áúã / ÁÆ°ÁêÜÊú¨Âú∞ÂàÜÊîØ
# alias gb='git branch'
# Êü•ÁúãÊâÄÊúâÂàÜÊîØÔºàÊú¨Âú∞ + ËøúÁ®ãÔºâ
# alias gba='git branch -a'
# ÂàáÊç¢ÂàÜÊîØ / ÊÅ¢Â§çÊñá‰ª∂ÔºàÊóßÂëΩ‰ª§Ôºâ
# alias gco='git checkout'
# Êñ∞Âª∫Âπ∂ÂàáÊç¢Âà∞‰∏Ä‰∏™ÂàÜÊîØ
# alias gcb='git checkout -b'
# ÂàáÊç¢ÂàÜÊîØÔºàÊñ∞Êé®ËçêÂëΩ‰ª§Ôºâ
# alias gsw='git switch'
# Êñ∞Âª∫Âπ∂ÂàáÊç¢Âà∞‰∏Ä‰∏™ÂàÜÊîØÔºàÊñ∞Êé®ËçêÂëΩ‰ª§Ôºâ
alias gswc='git switch -c'

# pull / pushÔºà‰∏çÂ∏¶ forceÔºâ
# alias gl='git pull'
# alias gp='git push'
alias gpv='git push --verbose'

# rebase / merge
# alias grb='git rebase'
# alias grbi='git rebase -i'
# alias gm='git merge'
# alias gma='git merge --abort'

# stash
# alias gsta='git stash'
# alias gstp='git stash pop'
# alias gstl='git stash list'
# alias gstd='git stash drop'

# resetÔºàÈùû hardÔºâ
# alias grs='git restore'
# alias grst='git restore --staged'

# HARD PULL: make local EXACTLY match remote (1:1)
# Usage:
#   githardpull                 # origin + current branch (or upstream if set)
#   githardpull upstream        # upstream + current branch
#   githardpull origin main     # origin/main
githardpull() {
  local remote="${1:-origin}"
  local branch="${2:-}"

  # Must be inside a git repo
  git rev-parse --git-dir >/dev/null 2>&1 || { echo "Not a git repository."; return 1; }

  # Determine branch
  if [[ -z "$branch" ]]; then
    branch="$(git symbolic-ref --quiet --short HEAD 2>/dev/null)"
    if [[ -z "$branch" ]]; then
      # Detached HEAD fallback: try upstream
      local up
      up="$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null)"
      if [[ -n "$up" ]]; then
        remote="${up%%/*}"
        branch="${up#*/}"
      else
        echo "Detached HEAD and no upstream configured. Use: githardpull <remote> <branch>"
        return 1
      fi
    fi
  fi

  echo "This will make LOCAL exactly match REMOTE:"
  echo "  LOCAL  : $(git rev-parse --show-toplevel)"
  echo "  TARGET : ${remote}/${branch}"
  echo "It will DISCARD:"
  echo "  - uncommitted changes"
  echo "  - staged changes"
  echo "  - local commits not on ${remote}/${branch}"
  echo
  echo -n "Type: RESET-LOCAL to continue: "
  local confirm
  read -r confirm
  [[ "$confirm" == "RESET-LOCAL" ]] || { echo "Cancelled."; return 1; }

  git fetch --prune "$remote" || return 1
  git reset --hard "${remote}/${branch}" || return 1
  git clean -df || return 1
  echo "Done. Local is now identical to ${remote}/${branch}."
}

# HARD PUSH: make remote EXACTLY match local (1:1)
# Usage:
#   githardpush                 # origin + current branch
#   githardpush upstream        # upstream + current branch
#   githardpush origin main     # push current HEAD to origin/main (force)
githardpush() {
  local remote="${1:-origin}"
  local branch="${2:-}"

  git rev-parse --git-dir >/dev/null 2>&1 || { echo "Not a git repository."; return 1; }

  # Determine current local branch
  local local_branch
  local_branch="$(git symbolic-ref --quiet --short HEAD 2>/dev/null)"
  if [[ -z "$local_branch" ]]; then
    echo "Detached HEAD. Checkout a branch first (or specify remote branch explicitly)."
    return 1
  fi

  # Default target branch = local branch
  [[ -z "$branch" ]] && branch="$local_branch"

  # Refuse if working tree dirty (optional but safer for ‚Äúrestore‚Äù workflows)
  if ! git diff --quiet || ! git diff --cached --quiet; then
    echo "Working tree or index has changes. Commit/stash or discard before hard-push."
    echo "If you REALLY want to proceed, clean it first or commit it."
    return 1
  fi

  echo "This will make REMOTE exactly match LOCAL:"
  echo "  LOCAL  : ${local_branch} @ $(git rev-parse --short HEAD)"
  echo "  REMOTE : ${remote}/${branch}"
  echo
  echo "WARNING: This can OVERWRITE remote history (other people's commits)."
  echo -n "Type: RESET-REMOTE to continue: "
  local confirm
  read -r confirm
  [[ "$confirm" == "RESET-REMOTE" ]] || { echo "Cancelled."; return 1; }

  git fetch --prune "$remote" || return 1

  # Use --force-with-lease for safety: force, but only if remote hasn't moved unexpectedly.
  # If you truly want unconditional overwrite, replace with: --force
  git push --force-with-lease "$remote" "HEAD:refs/heads/${branch}" || return 1

  echo "Done. Remote ${remote}/${branch} now matches local HEAD."
}


# SSH
alias ssh-key-install='ssh-copy-id -i /home/„Äê$CURRENT_USER„Äë/.ssh/id_rsa.pub'
alias sshpwdconnect='pwdconnect(){sshpass -p "$1" ssh};pwdconnect'

# ‰ª£ÁêÜ
alias all_proxy_sock5='export ALL_PROXY=socks5://127.0.0.1:20170'

# Â∫îÁî®Á®ãÂ∫è
# alias ffmpegss='ffmpegCutVideo(){ffmpeg -ss $3 -to $4 -i $1 -vcodec copy -acodec copy $2};ffmpegCutVideo'
# alias hcg='hexo clean && hexo g'
# alias p3='python3'

# Á≥ªÁªü
alias ssa='sudo systemctl start'
alias sss='sudo systemctl status'
alias ssd='sudo systemctl stop'
alias ssf='sudo systemctl restart'
alias ssaa='sudo systemctl enable'
alias ssdd='sudo systemctl disable'
alias zshrc='vim /home/„Äê$CURRENT_USER„Äë/.zshrc'
alias szsh='source /home/„Äê$CURRENT_USER„Äë/.zshrc'
alias upgrade='sudo apt update && sudo apt upgrade'
alias duls='du -sh ./*'
alias dulsd='du -sh `la`'

# enable auto-suggestions based on the history
if [ -f /usr/share/zsh-autosuggestions/zsh-autosuggestions.zsh ]; then
    . /usr/share/zsh-autosuggestions/zsh-autosuggestions.zsh
    # change suggestion color
    ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=#999'
fi

# Python3Ëá™ÂÆö‰πâÁöÑÂÖ®Â±ÄÁéØÂ¢ÉÊøÄÊ¥ª
alias acpy='activatePythonVenv'
function activatePythonVenv(){
    # Â¶ÇÊûúÂ≠òÂú®PythonËôöÊãüÁéØÂ¢ÉÊøÄÊ¥ªÊñá‰ª∂
    if [ -f "/home/„Äê$CURRENT_USER„Äë/.python_venv_activate" ];then
        source /home/„Äê$CURRENT_USER„Äë/.python_venv_activate
    fi
}

# ÈªòËÆ§ÊøÄÊ¥ªPythonÁéØÂ¢É 
activatePythonVenv
# export PATH="$PATH:/usr/sbin"

# Created by `pipx` on 2023-06-30 12:10:31
# :/usr/games:/usr/local/games
export PATH="$PATH:/home/„Äê$CURRENT_USER„Äë/.local/bin"
